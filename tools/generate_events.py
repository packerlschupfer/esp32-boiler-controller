#!/usr/bin/env python3
"""
Event Definition Code Generator

This tool generates type-safe event definitions from a YAML configuration file.
It ensures:
1. No bit position conflicts
2. Automatic documentation
3. Type-safe event groups
4. Centralized event management
"""

import yaml
import os
from datetime import datetime

# Example event configuration (would be in events.yaml)
EXAMPLE_CONFIG = """
event_groups:
  SystemState:
    description: "Overall system state events"
    events:
      - name: BOILER_ENABLED
        description: "Boiler system is enabled"
      - name: HEATING_ENABLED
        description: "Space heating is enabled"
      - name: WATER_ENABLED
        description: "Water heating is enabled"
      - name: BOILER_ON
        description: "Burner is currently on"
      - name: HEATING_ON
        description: "Heating pump is running"
      - name: WATER_ON
        description: "Water pump is running"
      - name: EMERGENCY_STOP
        description: "Emergency stop activated"
      - name: ERROR_ACTIVE
        description: "System error is active"

  BurnerRequest:
    description: "Burner request coordination"
    events:
      - name: HEATING
        description: "Space heating requesting burner"
      - name: WATER
        description: "Water heating requesting burner"
      - name: POWER_LOW
        description: "Low power mode requested"
      - name: POWER_HIGH
        description: "High power mode requested"
      - name: IGNITION
        description: "Ignition sequence requested"
      - name: SHUTDOWN
        description: "Shutdown requested"
    special_bits:
      # Reserve bits 16-23 for temperature encoding
      - start: 16
        end: 23
        name: TEMPERATURE_BITS
        description: "Encoded target temperature"

  SensorUpdate:
    description: "Temperature sensor update notifications"
    events:
      - name: BOILER_OUTPUT
        description: "Boiler output temperature updated"
      - name: BOILER_RETURN
        description: "Boiler return temperature updated"
      - name: WATER_TANK
        description: "Water tank temperature updated"
      - name: HEATING_RETURN
        description: "Heating return temperature updated"
      - name: OUTSIDE
        description: "Outside temperature updated"
      - name: INSIDE
        description: "Inside temperature updated"
      - name: ALL_SENSORS
        description: "All sensors updated"
"""

def generate_event_header(config):
    """Generate C++ header file from event configuration"""
    
    output = []
    output.append("// Generated by generate_events.py")
    output.append(f"// Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    output.append("// DO NOT EDIT - Changes will be overwritten")
    output.append("")
    output.append("#pragma once")
    output.append("")
    output.append("#include <freertos/FreeRTOS.h>")
    output.append("#include <freertos/event_groups.h>")
    output.append("")
    
    # Generate event definitions for each group
    for group_name, group_data in config['event_groups'].items():
        output.append(f"// ========== {group_name} Events ==========")
        output.append(f"// {group_data['description']}")
        output.append(f"namespace {group_name}Events {{")
        output.append("")
        
        bit_position = 0
        
        # Generate regular events
        if 'events' in group_data:
            for event in group_data['events']:
                output.append(f"    // {event['description']}")
                output.append(f"    constexpr EventBits_t {event['name']}_BIT = (1 << {bit_position});")
                bit_position += 1
                
        # Handle special bit reservations
        if 'special_bits' in group_data:
            output.append("")
            output.append("    // Special bit reservations")
            for special in group_data['special_bits']:
                output.append(f"    // {special['description']}")
                output.append(f"    constexpr int {special['name']}_START = {special['start']};")
                output.append(f"    constexpr int {special['name']}_END = {special['end']};")
                output.append(f"    constexpr EventBits_t {special['name']}_MASK = ((1 << ({special['end']} - {special['start']} + 1)) - 1) << {special['start']};")
                bit_position = max(bit_position, special['end'] + 1)
        
        # Generate utility constants
        output.append("")
        output.append("    // Utility masks")
        output.append(f"    constexpr EventBits_t ALL_BITS = ((1 << {bit_position}) - 1);")
        output.append(f"    constexpr int TOTAL_BITS_USED = {bit_position};")
        
        output.append("}")
        output.append("")
    
    # Generate event group enum for type safety
    output.append("// Event Group Type Enumeration")
    output.append("enum class EventGroupType {")
    for group_name in config['event_groups'].keys():
        output.append(f"    {group_name},")
    output.append("};")
    output.append("")
    
    # Generate centralized event group registry
    output.append("// Centralized Event Group Registry")
    output.append("class EventGroupRegistry {")
    output.append("private:")
    output.append("    struct GroupInfo {")
    output.append("        EventGroupHandle_t handle;")
    output.append("        const char* name;")
    output.append("        EventGroupType type;")
    output.append("    };")
    output.append("    ")
    for group_name in config['event_groups'].keys():
        output.append(f"    static EventGroupHandle_t {group_name.lower()}Group_;")
    output.append("")
    output.append("public:")
    output.append("    static void initialize() {")
    for group_name in config['event_groups'].keys():
        output.append(f"        {group_name.lower()}Group_ = xEventGroupCreate();")
    output.append("    }")
    output.append("")
    
    # Generate typed getters
    for group_name in config['event_groups'].keys():
        output.append(f"    static EventGroupHandle_t get{group_name}Group() {{")
        output.append(f"        return {group_name.lower()}Group_;")
        output.append(f"    }}")
        output.append("")
    
    output.append("};")
    output.append("")
    
    # Generate static member definitions
    output.append("// Static member definitions")
    for group_name in config['event_groups'].keys():
        output.append(f"inline EventGroupHandle_t EventGroupRegistry::{group_name.lower()}Group_ = nullptr;")
    
    return '\n'.join(output)

def generate_documentation(config):
    """Generate markdown documentation for events"""
    
    output = []
    output.append("# Event System Documentation")
    output.append("")
    output.append("## Event Groups")
    output.append("")
    
    for group_name, group_data in config['event_groups'].items():
        output.append(f"### {group_name}")
        output.append(f"{group_data['description']}")
        output.append("")
        output.append("| Bit | Event Name | Description |")
        output.append("|-----|------------|-------------|")
        
        bit_position = 0
        if 'events' in group_data:
            for event in group_data['events']:
                output.append(f"| {bit_position} | {event['name']} | {event['description']} |")
                bit_position += 1
        
        if 'special_bits' in group_data:
            for special in group_data['special_bits']:
                output.append(f"| {special['start']}-{special['end']} | {special['name']} | {special['description']} |")
        
        output.append("")
    
    return '\n'.join(output)

def main():
    # In real implementation, load from YAML file
    config = yaml.safe_load(EXAMPLE_CONFIG)
    
    # Generate header file
    header_content = generate_event_header(config)
    output_path = "include/events/GeneratedEvents.h"
    
    print("Generated header file:")
    print(header_content)
    
    # Generate documentation
    doc_content = generate_documentation(config)
    print("\nGenerated documentation:")
    print(doc_content)
    
    print(f"\nWould write to: {output_path}")
    print("Would write documentation to: docs/generated/events.md")

if __name__ == "__main__":
    main()