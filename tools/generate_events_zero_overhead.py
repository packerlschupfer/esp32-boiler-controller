#!/usr/bin/env python3
"""
Zero-Overhead Event Code Generator

Generates namespace-organized event constants from YAML configuration.
The output has ZERO runtime overhead - identical to #define macros.
"""

import yaml
import os
import sys
from datetime import datetime
from pathlib import Path

def generate_zero_overhead_header(config):
    """Generate zero-overhead C++ header with namespaced constants"""
    
    output = []
    
    # Header
    output.append("// Generated by generate_events_zero_overhead.py")
    output.append(f"// Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    output.append("// DO NOT EDIT - Changes will be overwritten")
    output.append("")
    output.append("#pragma once")
    output.append("")
    output.append("#include <freertos/FreeRTOS.h>")
    output.append("#include <freertos/event_groups.h>")
    output.append("")
    output.append("/**")
    output.append(" * Zero-Overhead Event System")
    output.append(" * ")
    output.append(" * This file provides organized event bit definitions using")
    output.append(" * namespaces. There is ZERO runtime overhead - these compile")
    output.append(" * to the same constants as #define macros.")
    output.append(" * ")
    output.append(" * Usage:")
    output.append(" *   xEventGroupSetBits(handle, SystemEvents::State::BOILER_ENABLED);")
    output.append(" * ")
    output.append(" * Instead of:")
    output.append(" *   xEventGroupSetBits(handle, SYSTEM_STATE_BOILER_ENABLED_BIT);")
    output.append(" */")
    output.append("")
    output.append("namespace SystemEvents {")
    output.append("")
    
    # Generate each event group
    for group_name, group_data in config['event_groups'].items():
        output.append(f"    // ===== {group_name} Events =====")
        output.append(f"    // Handle: {group_data.get('handle', 'TBD')}")
        output.append(f"    // {group_data['description']}")
        output.append(f"    namespace {group_name} {{")
        
        # Regular events
        if 'events' in group_data:
            max_bit = 0
            for event in group_data['events']:
                bit = event['bit']
                name = event['name']
                desc = event['desc']
                output.append(f"        constexpr EventBits_t {name} = (1UL << {bit}UL);  // {desc}")
                max_bit = max(max_bit, bit)
            
            output.append(f"        // Next free bit: {max_bit + 1}")
        
        # Special regions (like temperature encoding)
        if 'special_regions' in group_data:
            output.append("")
            output.append("        // Special bit regions")
            for region in group_data['special_regions']:
                name = region['name']
                start = region['start_bit']
                end = region['end_bit']
                desc = region['desc']
                
                output.append(f"        // {desc}")
                output.append(f"        constexpr int {name}_SHIFT = {start};")
                output.append(f"        constexpr int {name}_BITS = {end - start + 1};")
                output.append(f"        constexpr EventBits_t {name}_MASK = ((1UL << {name}_BITS) - 1) << {name}_SHIFT;")
                output.append(f"        ")
                output.append(f"        // Helper to encode/decode {name.lower()}")
                output.append(f"        constexpr EventBits_t encode_{name.lower()}(uint32_t value) {{")
                output.append(f"            return (value & ((1UL << {name}_BITS) - 1)) << {name}_SHIFT;")
                output.append(f"        }}")
                output.append(f"        constexpr uint32_t decode_{name.lower()}(EventBits_t bits) {{")
                output.append(f"            return (bits >> {name}_SHIFT) & ((1UL << {name}_BITS) - 1);")
                output.append(f"        }}")
        
        # Derived bits (combinations)
        if 'derived_bits' in group_data:
            output.append("")
            output.append("        // Useful combinations")
            for derived in group_data['derived_bits']:
                name = derived['name']
                expr = derived['expr']
                output.append(f"        constexpr EventBits_t {name} = {expr};")
        
        output.append(f"    }} // namespace {group_name}")
        output.append("")
    
    output.append("} // namespace SystemEvents")
    output.append("")
    
    # Generate handle declarations (optional)
    output.append("// Event Group Handle Declarations")
    output.append("// These should be defined in your initialization code:")
    output.append("/*")
    for group_name, group_data in config['event_groups'].items():
        handle = group_data.get('handle', f'x{group_name}EventGroup')
        output.append(f"extern EventGroupHandle_t {handle};")
    output.append("*/")
    output.append("")
    
    # Migration helper macros (optional)
    output.append("// Optional: Migration helper macros")
    output.append("// Uncomment these to help migrate from old #define style")
    output.append("/*")
    for group_name, group_data in config['event_groups'].items():
        if 'events' in group_data:
            for event in group_data['events']:
                old_style = f"{group_name.upper()}_{event['name']}_BIT"
                new_style = f"SystemEvents::{group_name}::{event['name']}"
                output.append(f"#define {old_style} {new_style}")
    output.append("*/")
    
    return '\n'.join(output)

def generate_usage_examples(config):
    """Generate usage examples for documentation"""
    
    output = []
    output.append("## Usage Examples")
    output.append("")
    output.append("### Setting Events")
    output.append("```cpp")
    output.append("// Old way:")
    output.append("xEventGroupSetBits(xSystemStateEventGroup, SYSTEM_STATE_BOILER_ENABLED_BIT);")
    output.append("")
    output.append("// New way (zero overhead):")
    output.append("xEventGroupSetBits(xSystemStateEventGroup, SystemEvents::SystemState::BOILER_ENABLED);")
    output.append("```")
    output.append("")
    output.append("### Waiting for Events")
    output.append("```cpp")
    output.append("// Wait for any temperature update")
    output.append("EventBits_t bits = xEventGroupWaitBits(")
    output.append("    xSensorEventGroup,")
    output.append("    SystemEvents::SensorUpdate::ALL_TEMPS,")
    output.append("    pdTRUE,   // Clear on exit")
    output.append("    pdFALSE,  // Wait for any")
    output.append("    pdMS_TO_TICKS(1000)")
    output.append(");")
    output.append("```")
    output.append("")
    output.append("### Encoding Values")
    output.append("```cpp")
    output.append("// Encode temperature in burner request")
    output.append("EventBits_t request = SystemEvents::BurnerRequest::HEATING |")
    output.append("                     SystemEvents::BurnerRequest::POWER_HIGH |")
    output.append("                     SystemEvents::BurnerRequest::encode_temperature(75);")
    output.append("")
    output.append("// Decode temperature from request")
    output.append("uint32_t temp = SystemEvents::BurnerRequest::decode_temperature(request);")
    output.append("```")
    
    return '\n'.join(output)

def main():
    # Parse arguments
    if len(sys.argv) < 2:
        print("Usage: generate_events_zero_overhead.py <config.yaml> [output.h]")
        sys.exit(1)
    
    config_file = sys.argv[1]
    
    # Load configuration
    with open(config_file, 'r') as f:
        config = yaml.safe_load(f)
    
    # Determine output file
    if len(sys.argv) > 2:
        output_file = sys.argv[2]
    else:
        output_file = config.get('output', {}).get('header', 'SystemEventsGenerated.h')
    
    # Generate header
    header_content = generate_zero_overhead_header(config)
    
    # Write header file
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w') as f:
        f.write(header_content)
    
    print(f"Generated: {output_path}")
    
    # Generate documentation if specified
    doc_file = config.get('output', {}).get('documentation')
    if doc_file:
        doc_content = generate_documentation(config) + "\n\n" + generate_usage_examples(config)
        doc_path = Path(doc_file)
        doc_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(doc_path, 'w') as f:
            f.write(doc_content)
        
        print(f"Generated: {doc_path}")

def generate_documentation(config):
    """Generate event documentation"""
    
    output = []
    output.append("# Event System Documentation")
    output.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    output.append("")
    output.append("## Overview")
    output.append("This system uses zero-overhead namespaced constants for event management.")
    output.append("All constants compile to the same machine code as traditional #define macros.")
    output.append("")
    output.append("## Event Groups")
    output.append("")
    
    for group_name, group_data in config['event_groups'].items():
        output.append(f"### {group_name}")
        output.append(f"**Handle:** `{group_data.get('handle', 'TBD')}`")
        output.append(f"**Description:** {group_data['description']}")
        output.append("")
        
        if 'events' in group_data:
            output.append("| Bit | Event | Description |")
            output.append("|-----|-------|-------------|")
            
            for event in sorted(group_data['events'], key=lambda x: x['bit']):
                output.append(f"| {event['bit']} | `{event['name']}` | {event['desc']} |")
        
        if 'special_regions' in group_data:
            output.append("")
            output.append("**Special Regions:**")
            for region in group_data['special_regions']:
                output.append(f"- Bits {region['start_bit']}-{region['end_bit']}: {region['desc']}")
        
        if 'derived_bits' in group_data:
            output.append("")
            output.append("**Derived Constants:**")
            for derived in group_data['derived_bits']:
                output.append(f"- `{derived['name']}`: {derived['expr']}")
        
        output.append("")
    
    return '\n'.join(output)

if __name__ == "__main__":
    main()